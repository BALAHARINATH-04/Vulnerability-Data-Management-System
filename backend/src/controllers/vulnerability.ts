import { Request,Response,NextFunction, RequestHandler } from "express"
import JwtPayload from "../models/decodedtokenModel"
import env from "../utilities/validateEnv"
import jwt from "jsonwebtoken"
import NVDCVEModel from "../models/NVDCVEModel"

export const vulnerabilityList:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                  $unwind: "$vulnerabilities"
                },
                {
                  $project:{
                    _id: 0,
                    id: "$vulnerabilities.cve.id",
                    identifier: "$vulnerabilities.cve.sourceIdentifier",
                    publishedDate: "$vulnerabilities.cve.published",
                    lastModified: "$vulnerabilities.cve.lastModified",
                    status: "$vulnerabilities.cve.vulnStatus"
                  }
                }
            ]
        )
        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

// export const vulnerabilitySingle:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
//     const {pageNo,pageSize}=req.body
//     const cveid=req.params.cveid
//     try{
//         const list=await NVDCVEModel.aggregate(
//             [
//                 {
//                   $unwind: "$vulnerabilities"
//                 },
//                 {
//                   $project:{
//                     _id: 0,
//                     id: "$vulnerabilities.cve.id",
//                     identifier: "$vulnerabilities.cve.sourceIdentifier",
//                     publishedDate: "$vulnerabilities.cve.published",
//                     lastModified: "$vulnerabilities.cve.lastModified",
//                     status: "$vulnerabilities.cve.vulnStatus"
//                   }
//                 },{
//                     $match:{
//                         id:cveid
//                     }
//                 }
//             ]
//         )
//         const dataLength=list.length
//         const pageNoInt=parseInt(pageNo)
//         const pageSizeInt=parseInt(pageSize)
//         const startIndex=(pageNoInt-1)*pageSize
//         const endIndex=pageNoInt*pageSize
//         const items=list.slice(startIndex,endIndex)

//         res.status(200).json({
//             pageNoInt:pageNoInt,
//             pageSizeInt:pageSizeInt,
//             totalLength:dataLength,
//             totalPages:Math.ceil(list.length/pageSize),
//             items:items,
//         })
//     }
//     catch(error){
//         next(error)
//     }
// }

export const vulnerabilityListID:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const cveid=req.params.cveid
        try {
            const cveData = await NVDCVEModel.aggregate([
                {
                    $unwind: "$vulnerabilities"
                },
                {
                    $match: {
                        "vulnerabilities.cve.id": cveid
                    }
                },
                {
                    $project: {
                        _id: 0,
                        id: "$vulnerabilities.cve.id",
                        description: {
                            $arrayElemAt: [
                                {
                                    $filter: {
                                        input: "$vulnerabilities.cve.descriptions",
                                        as: "desc",
                                        cond: { $eq: ["$$desc.lang", "en"] }
                                    }
                                },
                                0
                            ]
                        },
                        baseSeverity: "$vulnerabilities.cve.metrics.cvssMetricV2.baseSeverity",
                        baseScore: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.baseScore",
                        impactScore: "$vulnerabilities.cve.metrics.cvssMetricV2.impactScore",
                        exploitabilityScore: "$vulnerabilities.cve.metrics.cvssMetricV2.exploitabilityScore",
                        accessVector: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.accessVector",
                        accessComplexity: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.accessComplexity",
                        authentication: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.authentication",
                        confidentialityImpact: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.confidentialityImpact",
                        integrityImpact: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.integrityImpact",
                        availabilityImpact: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.availabilityImpact",
                        vectorString: "$vulnerabilities.cve.metrics.cvssMetricV2.cvssData.vectorString",
                        cpeMatch: {
                            $arrayElemAt: [
                                {
                                    $arrayElemAt: [
                                        {
                                            $arrayElemAt: [
                                                "$vulnerabilities.cve.configurations.nodes.cpeMatch",
                                                0
                                            ]
                                        },
                                        0
                                    ]
                                },
                                0
                            ]
                        }
                    }
                }
        ]);
        res.status(200).json({message:cveData})
    }
    catch(error){
        next(error)
    }
}

export const vulnerabilityListYear:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    const year=req.params.year
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                  $unwind: "$vulnerabilities"
                },
                {
                  $project:{
                    _id: 0,
                    id: "$vulnerabilities.cve.id",
                    identifier: "$vulnerabilities.cve.sourceIdentifier",
                    publishedDate: "$vulnerabilities.cve.published",
                    lastModified: "$vulnerabilities.cve.lastModified",
                    status: "$vulnerabilities.cve.vulnStatus"

                  }
                },
                {
                    $match:{
                        $expr: { 
                            $eq: [ 
                              { $substr: ["$publishedDate", 0, 4] }, 
                              year
                            ] 
                          }
                    }
                }
            ]
        )

        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

export const vulnerabilityListScore:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    const score=parseFloat(req.params.score)
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                    $unwind: "$vulnerabilities"
                },
                {
                    $project: {
                        _id: 0,
                        id: "$vulnerabilities.cve.id",
                        identifier: "$vulnerabilities.cve.sourceIdentifier",
                        publishedDate: "$vulnerabilities.cve.published",
                        lastModified: "$vulnerabilities.cve.lastModified",
                        status: "$vulnerabilities.cve.vulnStatus",
                        cvssData: {
                            $arrayElemAt: ["$vulnerabilities.cve.metrics.cvssMetricV2", 0]
                        }
                    }
                },
                {
                    $match: {
                        "cvssData.cvssData.baseScore": score
                    }
                }
            ]
        )

        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

export const vulnerabilityListNDays:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    const Ndays=parseInt(req.params.Ndays)*24*60*60*1000
    const currentTimestamp=Date.now()
    const timeDiff=currentTimestamp-Ndays
    const NDate=(new Date(timeDiff))
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                  $unwind: "$vulnerabilities"
                },
                {
                  $project:{
                    _id: 0,
                    id: "$vulnerabilities.cve.id",
                    identifier: "$vulnerabilities.cve.sourceIdentifier",
                    publishedDate: "$vulnerabilities.cve.published",
                    lastModified: "$vulnerabilities.cve.lastModified",
                    status: "$vulnerabilities.cve.vulnStatus"

                  }
                },
                {
                $addFields: {
                    convertedDate: {
                    $toDate: "$lastModified"
                    }
                }
                },
                {
                    $match: {
                        convertedDate: { $gt: NDate }
                      }
                }
            ]
        )
        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

export const vulnerabilityListPublishedDateSortAsc:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                  $unwind: "$vulnerabilities"
                },
                {
                  $project:{
                    _id: 0,
                    id: "$vulnerabilities.cve.id",
                    identifier: "$vulnerabilities.cve.sourceIdentifier",
                    publishedDate: "$vulnerabilities.cve.published",
                    lastModified: "$vulnerabilities.cve.lastModified",
                    status: "$vulnerabilities.cve.vulnStatus"

                  }
                },
                {
                    $sort:{
                        publishedDate:1
                    }
                }
            ]
        )
        
        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

export const vulnerabilityListPublishedDateSortDesc:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                  $unwind: "$vulnerabilities"
                },
                {
                  $project:{
                    _id: 0,
                    id: "$vulnerabilities.cve.id",
                    identifier: "$vulnerabilities.cve.sourceIdentifier",
                    publishedDate: "$vulnerabilities.cve.published",
                    lastModified: "$vulnerabilities.cve.lastModified",
                    status: "$vulnerabilities.cve.vulnStatus"

                  }
                },
                {
                    $sort:{
                        publishedDate:-1
                    }
                }
            ]
        )

        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

export const vulnerabilityListModifiedDateSortAsc:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                  $unwind: "$vulnerabilities"
                },
                {
                  $project:{
                    _id: 0,
                    id: "$vulnerabilities.cve.id",
                    identifier: "$vulnerabilities.cve.sourceIdentifier",
                    publishedDate: "$vulnerabilities.cve.published",
                    lastModified: "$vulnerabilities.cve.lastModified",
                    status: "$vulnerabilities.cve.vulnStatus"

                  }
                },
                {
                    $addFields: {
                        convertedDate: {
                        $toDate: "$lastModified"
                        }
                    }
                },
                {
                    $sort:{
                        convertedDate:1
                    }
                }
            ]
        )

        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

export const vulnerabilityListModifiedDateSortDesc:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const {pageNo,pageSize}=req.body
    try{
        const list=await NVDCVEModel.aggregate(
            [
                {
                  $unwind: "$vulnerabilities"
                },
                {
                  $project:{
                    _id: 0,
                    id: "$vulnerabilities.cve.id",
                    identifier: "$vulnerabilities.cve.sourceIdentifier",
                    publishedDate: "$vulnerabilities.cve.published",
                    lastModified: "$vulnerabilities.cve.lastModified",
                    status: "$vulnerabilities.cve.vulnStatus"

                  }
                },
                {
                    $sort:{
                        lastModified:-1
                    }
                }
            ]
        )

        const dataLength=list.length
        const pageNoInt=parseInt(pageNo)
        const pageSizeInt=parseInt(pageSize)
        const startIndex=(pageNoInt-1)*pageSize
        const endIndex=pageNoInt*pageSize
        const items=list.slice(startIndex,endIndex)

        res.status(200).json({
            pageNoInt:pageNoInt,
            pageSizeInt:pageSizeInt,
            totalLength:dataLength,
            totalPages:Math.ceil(list.length/pageSize),
            items:items,
        })
    }
    catch(error){
        next(error)
    }
}

export const authenticate:RequestHandler=async(req:Request,res:Response,next:NextFunction)=>{
    const token=req.cookies.VMSToken
    if(!token){
        res.status(401).json({message:"Unauthorized: No token provided"})
    }
    try{
        const decoded=jwt.verify(token,env.SECRET_KEY) as JwtPayload
        if(decoded){
            next()
        }
        else{
            res.status(406).json({message:"Invalid token"})
        }
    }
    catch(error){
        next(error)
    }
}